# 认识 ByteView

简答来说，ByteView 是一个 **只读、不可变的数据视图**，它的核心目标是：**统一地表示缓存值**。

## 主要作用
- 在缓存系统中，所有存入的缓存值，无论是图片、文字、还是任何其他格式，最终都会被存储为字节序列（[]byte）。
- ByteView激素hi对这一字节序列的封装。
- 它提供了一组方法（如：获取长度、转为字符串、获取副本等），让使用者可以安全地读取或转换这些数据，同时确保原始数据不会被意外修改。

## 设计初衷

- ByteView 的设计时为了屏蔽底层是 []byte 还是 string 的差异，提供统一的接口。

## 方法接收器不使用指针！

ByteView 的方法接收器都定义为 (b ByteView) 而非 (b *ByteView)。

这是有意为之的设计，其背后的考量可以概括为下表：

|设计考量	| 值接收器 (b ByteView) 的益处	|说明|
|:----------:|:----------|:----------|
|​ **保证不可变性​**	| 核心优势。方法操作的是原结构体的副本，无法修改原实例的内部数据（如其 b []byte 字段）。| 这是实现只读视图、保证缓存数据安全性的基石。|​
| **符合值语义​**	   | 结构体被设计为值类型，类似于 time.Time。传递和赋值时会产生拷贝，行为更可预测。	| 官方注释建议将其作为值类型使用，而非指针。|
|**避免浅拷贝陷阱​**	|即使使用值接收器，其内部包含的切片（[]byte）底层数组也未被复制​（仍是浅拷贝）。ByteSlice() 等方法通过返回副本来防止外部修改底层数据。 | 若使用指针接收器，反而可能误导使用者认为可以直接修改内部数据。|