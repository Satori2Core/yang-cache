# lru2Store 设计说明

`lru2Store` 是一个典型的**本地二级缓存**实现，其核心目标是在单机环境下，通过两级缓存结构实现对高频访问数据的高速读取，同时有效管理内存资源。

## 设计速览理解

这个二级缓存系统采用了分片 + 二级缓存的混合架构：

### 核心设计特点

1. **分片并发**​：通过哈希分片将数据分布到多个独立区域，每个分片有自己的锁，大幅减少锁竞争
2. **二级缓存策略**​：
    - **​L1缓存**​：容量较小，存储最新访问的数据，作为"工作缓存"
    - **​L2缓存**​：容量较大，存储从L1晋升的较常访问数据
3. **​数据流动**​：读取时数据从L1晋升到L2，新数据总是写入L1
4. **双重清理**​：惰性删除（访问时检查） + 定期清理（后台协程）

工作流程
```go
新数据写入 → L1缓存 → 被频繁读取 → 晋升到L2缓存 → 长期驻留
    ↓
过期/淘汰 ← 定期清理/内存不足 ← 长期未访问 ← 淘汰到L2末尾
```


---

## 整体数据流

系统的数据流动遵循着精细的生命周期管理，下图描绘了其核心工作流程，特别是数据在获取（Get）与设置（Set）过程中的状态变化与晋升逻辑：

![alt text](../images/lru2Store.png)

---

## 核心组件与职责

该设计主要包含两个核心层级：

- **​一级缓存**​：容量较小，作为工作缓存区，用于存储最新访问或设置的数据，响应速度极快。
- ​**二级缓存**​：容量较大，作为稳定缓存区，用于存放从一级缓存晋升过来的、相对更常被访问的数据，保证较高命中率。

这种设计模仿了计算机体系结构中的多级缓存思想（如CPU的L1、L2缓存），旨在将有限的内存资源优先服务于最有可能被再次访问的数据。

---

## 核心机制解析

### LRU淘汰算法

`lru2Store` 在每一级缓存内部都实现了标准的`LRU`算法。其核心是通过**哈希表​**和**双向链表** 的组合来管理数据：

- **​哈希表​**：提供O(1)时间复杂度的数据查找能力。
- **双向链表**：维护数据的访问顺序，最近访问的置于头部，最久未访问的置于尾部。当缓存已满时，淘汰链尾数据。

在代码中，`adjust(idx, f, t)`方法是维护LRU顺序的关键，它通过调整节点在双向链表中的位置（移动到头部或尾部）来标记其访问状态。

---

### 内存管理

`lru2Store` 在内存管理上做了多项优化，以追求高性能和低GC压力：

- **​内存预分配**​：在缓存初始化时，即预分配好固定大小的数组（`[]node`）来存储节点，`dlnk`数组存储索引链接。这极大地减少了运行时内存分配和垃圾回收的次数。
- **​索引化链表​**：与使用指针的传统链表不同，此实现使用`uint16`类型的索引来构建链表。这种方式更节省内存，并且所有数据操作都在预分配的结构内进行，避免了频繁的内存分配与释放。
- **自定义时钟​**：为了避免频繁调用`time.Now()`带来的系统开销，系统内部维护了一个自定义的时钟变量`clock`，由一个独立的`goroutine`负责以“一次系统调用+九次原子递增”的方式更新，平衡了精度与性能。

---

### 并发安全控制

`lru2Store` 采用**分片锁**技术来实现高并发访问。

- 它将数据划分为多个分片（如16个），每个分片拥有独立的互斥锁。
- 当操作一个键时，首先通过哈希函数确定其所在分片，然后仅锁定该分片。

这样，不同分片上的操作可以完全并行，显著降低了锁竞争，提升了系统的整体吞吐量。

---

##  关键设计决策解析

### 数据晋升策略

一个关键设计是**仅在读取时触发数据从L1到L2的晋升**。这意味着：
- **​新加入的数据**总是直接放在L1。
- 只有当数据在L1中被**再次读取**，才被认为有足够价值被晋升到L2。

这种策略确保了L2中存放的是经过初步验证的、相对更“热”的数据，优化了L2缓存空间的使用效率。

---

### 过期处理机制

`lru2Store` 结合了两种过期数据清理方式：

- **​惰性删除**​：在执行Get、Set操作时，如果发现数据已过期，则立即删除。
- **​定期清理**​：由后台协程定时扫描并清理所有分片中的过期数据。

这种“主动+被动”的方式既能及时释放内存，又避免了过期数据长期占用空间。

---

## 与工业级方案对比

为了更全面地评估此缓存设计，下表将其与工业界常见的Caffeine + Redis两级缓存架构进行了对比：

| 对比维度	|  本实现 (lru2Store)	| Caffeine + Redis 架构 |
|:---------:|:---------|:---------|​

| 应用场景​	​|  单机应用内部高性能缓存      | 分布式系统，多实例间数据共享与一致性 |
​| 数据一致性​	| 相对简单，单机内部一致	    | 需通过Redis Pub/Sub或消息队列同步各节点本地缓存，实现复杂 |

​| 延迟​	    | 极低，无网络开销	        | 本地读取极快，但缓存未命中或写操作需网络访问Redis |

​| 容量​	    | 受单机内存限制	        | L2（Redis）可横向扩展，容量更大 |

​| 复杂度​	    | 实现相对自包含，逻辑清晰	| 需引入并维护Redis等外部组件，系统复杂度更高 |