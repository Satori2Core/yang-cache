# LruCache 设计解析

- 代码实现了一个功能完整的**线程安全LRU缓存**，支持**过期时间**和**内存限制**。
- 它结合了**双向链表**、**哈希映射**和**互斥锁**，是构建高性能缓存系统的核心组件。

## 核心代码解析

### 关键数据结构

代码通过三个核心部分协同工作：

- **双向链表**（list.List）：维护缓存项的**访问数据**。链表头部是**最久未使用**的项，尾部是**最近使用**的项。任何被访问过或更新过的项都会被移动到链表尾部。eg：`SetWithExpiration(...)` 方法。
- **项目映射**（item map[string]*list.Element）：一个哈希表，用于支持通过键快速定位到列表中的具体节点，实现O(1)时间复杂度的查询。
- **过期时间映射**(expires map[string]time.Time)​​：另一个哈希表，独立记录每个键的绝对过期时间点，方便快速判断和定期清理。过期时间映射。

通过“哈希表+双向链表”的结构是实现高效LRU缓存的经典模式，在保证快速查找的同时，也能高效地维护方位顺序和进行节点淘汰。

---

### 核心操作流程

下图梳理了 Get 和 Set 方法的关键执行路径及线程安全控制：

[lru_get_set_image](../images/lruCache.png)

需要特别说明的是，流程中的“检查键是否存在”、“检查是否过期”、“更新链表结构”以及“淘汰节点”等步骤，都在互斥锁 (sync.RWMutex) 的保护下进行，从而保证了线程安全。Get 操作在发现过期键时，为了避免在持有读锁的情况下进行写操作，选择异步删除，这是一种优化策略。

---

### 内存管理与淘汰策略

- **容量控制**​：通过 maxBytes 和 usedBytes 跟踪内存使用。当添加新项或更新现有项导致 usedBytes > maxBytes 时，会触发 evict() 函数。
- **双重清理机制​**：evict() 函数会执行两步清理：
    - **清理过期项​**：遍历 expires 映射，删除所有已过期的项。
    - **LRU淘汰**​：如果清理过期项后仍超限，则持续从链表头部​（最久未使用）移除节点，直到满足内存限制。
- **定期清理**​：一个独立的 cleanupLoop 协程会定期（例如每分钟）执行 evict()，防止大量已过期但未被访问的数据长期占用内存。

---

### 线程安全与优雅关闭

- **锁机制**​：使用 sync.RWMutex 实现线程安全。Get 操作使用读锁（允许多个读并发），修改缓存的操作使用写锁（确保互斥）。
- **​优雅关闭**​：Close 方法通过 closeCh 通道通知 cleanupLoop 协程退出，避免协程泄漏。

---


## 缓存设计示意图

以下图示展示了某一时刻缓存的内存结构状态，以及添加新元素触发LRU淘汰的数据变化过程：

```markdown
初始状态 (假设 maxBytes = 300, 当前已使用 250)

    双向链表 (按访问时间排序: 最久未使用 -> 最近使用)
    Head (最久)                               Tail (最新)
     |                                        |
     | key: A, value: ... | <--> | key: C, value: ... | <--> | key: B, value: ... |
     |                        |                        |
     ----- items["A"] ------------ items["C"] ------------ items["B"] ------

过期时间映射 (expires)
key: A -> 2023-10-27 10:00:00
key: B -> 2023-10-27 11:00:00
key: C -> (无过期时间)

usedBytes = 250
```

**操作**：​​ Set("D", largeValue) （假设 largeValue 大小为 100 字节）

**​执行步骤**：​​

- ​计算新大小​：usedBytes 将变为 250 + 100 = 350 > 300，触发淘汰。
- 淘汰最久未使用项 (A)​​：
    - 从链表头部移除 A。
    - 从 items 和 expires 中删除 key A。
    - usedBytes 减少 A 的大小，假设减至 220。
    - 350 > 300，继续淘汰。
- 淘汰下一项 (C)​​：
    - 移除 C。
    - usedBytes 进一步减少，假设减至 150。
    - 150 + 100 = 250 < 300，停止淘汰。
- 插入新项 (D)​​：
    - 将 D 对应的新节点添加到链表尾部。
    - 在 items 中设置 items["D"] = pointerToNewNode。
    - usedBytes 更新为 250。

---

## 代码实现的意义与价值

这个LRU缓存实现的意义在于：

- **​高性能访问**​：结合哈希表和双向链表，实现了近似O(1)时间复杂度的读取和插入。
- ​**可控的资源占用**​：通过内存限制和LRU淘汰策略，有效防止缓存无限增长导致内存溢出。
- **数据有效期管理**​：支持TTL，自动清理过期数据，保证数据的相对新鲜度。
- ​**线程安全**​：可在多线程并发环境下安全使用，适合网络服务等场景。
- ​**生产级特性**​：提供了优雅关闭、可选的淘汰回调(onEvicted)、动态调整内存上限(SetMaxBytes)等特性，使其更适用于实际项目。